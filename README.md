# Метро в тандеме

<a href="/misc/8.Техническое задание.pdf">Техническое задание</a></br>
<a href="/misc/presentation.pdf">Презентация</a>  
<a href="https://i.moscow/lct">Хакатон</a>      

# Введение

## Обзор основных компонентов

Эта документация описывает развертывание системы, состоящей из нескольких контейнеров Docker, которые обеспечивают работу баз данных, ETL-процесса, бекенда и фронтенда. Все компоненты взаимодействуют друг с другом для предоставления полноценного решения.

Система состоит из следующих основных компонентов:

- **Фронтенд**: Веб-интерфейс для взаимодействия с пользователем
    - <a href="/web">/web</a>     
    - [https://метровтандеме.рф](https://метровтандеме.рф)
- **Бекенд**: Сервис, предоставляющий API и логику приложения.
    - <a href="/internal">/internal</a>   
    - [https://api.метровтандеме.рф](https://api.xn--80adhbda7bfghvxd.xn--p1ai/swagger-ui/index.html)
- **ETL-процесс**: Обработка данных и их перемещение из JSON в хранилище.
    - <a href="/etl">/etl</a>
- **База данных**: Используется PostgreSQL для хранения данных.

# Требования к АО и ПО

## Список аппаратных и программных требований

Аппаратные требования

- Процессор: Минимум двухъядерный процессор
- Оперативная память: 4 ГБ и выше
- Место на диске: 20 ГБ и выше
- Поддержка виртуализации на уровне процессора

Программные требования

- Docker версии 19.03 и выше
- Docker Compose версии 1.25.0 и выше
- Поддержка виртуализации на уровне ОС

## Инструкции по установке и настройке необходимого ПО

### Установка Docker:

Для Windows и MacOS скачайте и установите Docker Desktop с официального сайта Docker.

Для Linux выполните следующие команды:

```bash
sudo apt-get update
sudo apt-get install docker
```

### Установка Docker Compose:

Выполните следующую команду для установки Docker Compose:

```bash
sudo apt-get install docker-compose
```

# Архитектура

## Обзор архитектуры веб-сервиса, включая используемые технологии,
компоненты и их взаимодействие

### Backend (Kotlin с использованием Spring Boot)

Веб-сервис построен на основе Kotlin с использованием Spring Boot, что обеспечивает быструю разработку и управление приложениями. Основные используемые технологии включают:

- **Spring Boot**: Фреймворк для создания автономных, готовых к продакшену приложений на основе Spring.
- **Spring Security**: Инфраструктура для обеспечения аутентификации и авторизации в приложениях.
- **Spring Data JPA**: Упрощает взаимодействие с базами данных через JPA (Java Persistence API) и Hibernate.
- **Spring Actuator**: Предоставляет возможности мониторинга и управления приложением в реальном времени.
- **Liquibase:** Читает .XML файлы с оописанием миграции баз данных.

### Frontend (Svelte с использованием Vite)

Фронтенд приложения разработан на базе Svelte с использованием Vite для быстрой сборки и разработки. Важные компоненты включают:

- **Svelte**: Прогрессивный фреймворк JavaScript для построения пользовательских интерфейсов.
- **Vite**: Быстрый инструмент сборки для современных веб-приложений с поддержкой быстрого развертывания и горячей перезагрузки.
- **Tailwind CSS**: Библиотека CSS, которая упрощает стилизацию компонентов и создание адаптивного дизайна.

### Взаимодействие компонентов

- **Фронтенд и бекенд**: Фронтенд обращается к бекенду через API, предоставляемые Spring Boot. Это включает запросы на получение данных, отправку данных и аутентификацию пользователя (JWT).
- **База данных**: Бекенд взаимодействует с PostgreSQL для хранения и извлечения данных. Используется Spring Data JPA для выполнения операций CRUD (Create, Read, Update, Delete).
- **Безопасность и аутентификация**: Spring Security обеспечивает защиту API и управление доступом к различным ресурсам в зависимости от роли пользователя.

### Развёртывание и сборка

- Проект поддерживается и собирается при помощи инструментов сборки Gradle и npm (Node Package Manager).

## Диаграммы, поясняющая структуру и поток данных

Пользователь получает SSR страницу с сервиса Vercel, затем браузер пользователя с загруженной страницей обращается к API хоста бэкенда, в запросах с данными идет вызов запросов к базе данных.

![Архитектура](/misc/images/architecture.png)

# Инструкция по развертыванию

### Клонирование репозитория:

Перейдите в директорию, где вы хотите разместить проект, и выполните команду:

```bash
git clone https://github.com/funcid/metro-in-tandem.git
cd metro-in-tandem
```

### Запуск проекта:

```bash
docker-compose up --build
```

**База данных (PostgreSQL)**: будет доступна на порту, указанном в переменной `POSTGRES_PORT` в файле `.env`. По умолчанию это порт 5432

**Бэкенд**: будет доступен на порту 8080

**Фронтенд**: будет доступен на порту 3000

**ETL:** перенесет данные из JSON файлов и загрузит их в базу

# Инструкция по эксплуатации

## Описание доступных API методов и их параметров и ожидаемых ответов

Динамическое описание API методов доступно в Swagger по ссылке:

[https://api.метровтандеме.рф/swagger-ui/index.html](https://api.xn--80adhbda7bfghvxd.xn--p1ai/swagger-ui/index.html)

## Инструкции по аутентификации и авторизации

1. Посетите сайт [https://метровтандеме.рф](https://метровтандеме.рф) 

    ![Главная страница](/misc/images/main.png)
    
2. Нажмите “Войти” или любую кнопку из меню навигации
    
    ![Страница входа](/misc/images/login.png)
    
3. Введите логин и пароль, по умолчанию, доступны следующие учетные записи с ролями:
    
    ![Заполненная анкета](/misc/images/data.png)
    
    1. Администратор
        
        ```bash
        admin_user
        admin_pass
        ```
        
    2. Специалист
        
        ```bash
        specialist_user
        specialist_pass
        ```
        
    3. Оператор
        
        ```bash
        operator_user
        operator_pass
        ```
        
    4. Работник
        
        ```bash
        admin_user
        admin_pass
        ```
        
4. Справа сверху исчезнет кнопка “Войти” и появится активная учетная запись
    
    ![Успешный вход](/misc/images/authorized.png)
    
5. Для выхода из учетной записи нажмите на кнопку справа сверху, далее: Выйти
    
    ![Выход](/misc/images/logout.png)

# Описание алгоритма распределения заявок

## Компоненты

- **AllocationService**: основной сервис, который управляет распределением заявок.
- **applicationRepository**: репозиторий для работы с заявками.
- **employeeRepository**: репозиторий для работы с сотрудниками.
- **pathfinderService**: сервис для расчета времени перемещения между станциями.

## Поля

- **allocation**: карта, связывающая сотрудников с расширенными заявками.

## Основные функции

1. **allocateApplications(from: Long, to: Long): Map<Employee, List<ExtendedApplication>>**
   - Извлекает всех сотрудников и подходящие заявки в указанный период.
   - Распределяет заявки между подходящими сотрудниками.
   - Обеспечивает наличие обеденного перерыва у всех сотрудников.
   - Логирует неудачные распределения.
   - Возвращает распределенные заявки.

2. **findValidApplications(from: Long, to: Long): List<Application>**
   - Находит заявки между заданными временными метками, исключая отмененные.

3. **allocateToSuitableEmployees(employees: List<Employee>, applications: List<Application>)**
   - Разделяет сотрудников на группы по рангу ("ЦИ" и "ЦСИ").
   - Инициализирует пустые списки заявок для каждого сотрудника.
   - Для каждой заявки ищет подходящих сотрудников и выбирает лучшего, учитывая время перемещения.

4. **findSuitableEmployees(ciEmployees: List<Employee>, csiEmployees: List<Employee>, application: Application): List<Employee>**
   - Находит подходящих сотрудников из групп "ЦИ" и "ЦСИ" для данной заявки.

5. **findBestEmployeeAndTravelTime(employees: List<Employee>, application: Application): Pair<Employee, Double>**
   - Находит лучшего сотрудника для заявки на основе минимального времени перемещения.

6. **ensureLunchBreakForAllEmployees()**
   - Обеспечивает наличие обеденного перерыва у всех сотрудников, добавляя обеденные заявки.

7. **createLunchApplication(employee: Employee, lunchStart: LocalTime): Application**
   - Создает фиктивную заявку для обеда.

8. **calculateLunchTime(employee: Employee, extendedApplications: List<ExtendedApplication>): LocalTime?**
   - Рассчитывает подходящее время для обеденного перерыва, проверяя наличие достаточного промежутка времени между заявками.

9. **forceLunchBreak(employee: Employee)**
   - Принудительно устанавливает обеденный перерыв для сотрудника, если подходящее время не найдено.

10. **isEmployeeAvailable(employee: Employee, application: Application): Boolean**
    - Проверяет, доступен ли сотрудник для новой заявки с учетом его расписания и уже назначенных заявок.

11. **parseWorkTime(timeWork: String): Pair<LocalTime, LocalTime>**
    - Парсит строку с рабочим временем сотрудника в пару значений LocalTime.

12. **isWithinWorkHours(start: LocalTime, end: LocalTime, workStart: LocalTime, workEnd: LocalTime, crossesMidnight: Boolean): Boolean**
    - Проверяет, находится ли временной интервал внутри рабочего времени сотрудника.

13. **isValidLunchTime(lunchStart: LocalTime, lunchEnd: LocalTime, workStart: LocalTime, workEnd: LocalTime, applications: List<ExtendedApplication>, crossesMidnight: Boolean): Boolean**
    - Проверяет, является ли предложенное время обеда допустимым.

14. **estimateTravelTime(lastApplication: Application?, newApplication: Application): Double**
    - Оценивает время перемещения между станциями последней заявки и новой заявки.

15. **logFailedAllocations()**
    - Логирует сотрудников, для которых не удалось распределить заявки.

## Основной поток

1. **Получение данных**
   - Извлекаются все сотрудники и подходящие заявки.

2. **Распределение заявок**
   - Заявки распределяются среди подходящих сотрудников на основе их доступности и минимального времени перемещения.

3. **Обеденные перерывы**
   - Проверяется наличие обеденных перерывов у всех сотрудников, при необходимости добавляются фиктивные заявки для обеда.

4. **Логирование**
   - Сотрудники, для которых не удалось распределить заявки, логируются.

Этот алгоритм обеспечивает оптимальное распределение заявок, учитывая рабочее время сотрудников, их занятость и необходимость обеденных перерывов.

# Оценка сложности алгоритма распределения заявок

Для оценки сложности алгоритма распределения заявок в терминах Big O рассмотрим ключевые части кода и их влияние на общую сложность.

## Основная функция: `allocateApplications`

1. **Получение всех сотрудников**:
   ```kotlin
   val employees = employeeRepository.findAll().toList().distinctBy { it.id }
   ```
   - Сложность: $ O(E) $ (где $ E $ — количество сотрудников).

2. **Поиск валидных заявок**:
   ```kotlin
   val applications = findValidApplications(from, to).distinctBy { it.id }
   ```
   - Сложность: $ O(A) $ (где $ A $ — количество заявок).

3. **Распределение заявок**:
   ```kotlin
   allocateToSuitableEmployees(employees, applications)
   ```
   - Основная сложность алгоритма скрыта в этой функции.

4. **Обеспечение обеденных перерывов**:
   ```kotlin
   ensureLunchBreakForAllEmployees()
   ```
   - Сложность: $ O(E) $.

## Функция `allocateToSuitableEmployees`

1. **Инициализация пустых списков заявок для сотрудников**:
   ```kotlin
   (ciEmployees + csiEmployees).forEach { employee ->
       allocation[employee] = mutableListOf()
   }
   ```
   - Сложность: $ O(E) $.

2. **Сортировка заявок по времени**:
   ```kotlin
   applications.sortedBy { it.time4 }
   ```
   - Сложность: $ O(A \log A) $.

3. **Распределение каждой заявки**:
   ```kotlin
   applications.forEach { app ->
       val suitableEmployees = findSuitableEmployees(ciEmployees, csiEmployees, app)
       if (suitableEmployees.isNotEmpty()) {
           val (employee, travelTime) = findBestEmployeeAndTravelTime(suitableEmployees, app)
           allocation[employee]?.add(ExtendedApplication(app, travelTime))
       }
   }
   ```
   - Итерация по всем заявкам: $ O(A) $.
   - Внутри каждой итерации:
     - **Поиск подходящих сотрудников**: $ O(E) $.
     - **Поиск лучшего сотрудника и времени перемещения**: $ O(E) $.

## Функция `ensureLunchBreakForAllEmployees`

1. **Проверка и добавление обеденных перерывов**:
   ```kotlin
   allocation.keys.forEach { employee ->
       val extendedApplications = allocation[employee] ?: return@forEach
       val lunchTime = calculateLunchTime(employee, extendedApplications)
       if (lunchTime != null) {
           allocation[employee]?.add(ExtendedApplication(createLunchApplication(employee, lunchTime), 0.0))
       } else {
           forceLunchBreak(employee)
       }
   }
   ```
   - Сложность: $ O(E \cdot A) $ (в худшем случае, проверка всех заявок каждого сотрудника).

## Итоговая сложность

Общая сложность алгоритма распределения заявок складывается из сложностей всех ключевых функций. Основные факторы, влияющие на сложность:
- Сортировка заявок: $ O(A \log A) $.
- Распределение заявок: $ O(A \cdot E) $.
- Обеспечение обеденных перерывов: $ O(E \cdot A) $.

Таким образом, итоговая сложность алгоритма:

$$ O(A \log A + A \cdot E + E \cdot A) $$

Так как $ A \cdot E $ доминирует, итоговая асимптотическая сложность:

$$ O(A \cdot E) $$

Где:
- $ A $ — количество заявок.
- $ E $ — количество сотрудников.