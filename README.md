# Метро в тандеме

<a href="/misc/8.Техническое задание.pdf">Техническое задание</a></br>
<a href="/misc/presentation.pdf">Презентация</a>  
<a href="https://i.moscow/lct">Хакатон</a>      

# Введение

## Обзор основных компонентов

Эта документация описывает развертывание системы, состоящей из нескольких контейнеров Docker, которые обеспечивают работу баз данных, ETL-процесса, бекенда и фронтенда. Все компоненты взаимодействуют друг с другом для предоставления полноценного решения.

Система состоит из следующих основных компонентов:

- **Фронтенд**: Веб-интерфейс для взаимодействия с пользователем
    - <a href="/web">/web</a>     
    - [https://метровтандеме.рф](https://метровтандеме.рф)
- **Бекенд**: Сервис, предоставляющий API и логику приложения.
    - <a href="/internal">/internal</a>   
    - [https://api.метровтандеме.рф](https://api.xn--80adhbda7bfghvxd.xn--p1ai/swagger-ui/index.html)
- **ETL-процесс**: Обработка данных и их перемещение из JSON в хранилище.
    - <a href="/etl">/etl</a>
- **База данных**: Используется PostgreSQL для хранения данных.

# Требования к АО и ПО

## Список аппаратных и программных требований

Аппаратные требования

- Процессор: Минимум двухъядерный процессор
- Оперативная память: 4 ГБ и выше
- Место на диске: 20 ГБ и выше
- Поддержка виртуализации на уровне процессора

Программные требования

- Docker версии 19.03 и выше
- Docker Compose версии 1.25.0 и выше
- Поддержка виртуализации на уровне ОС

## Инструкции по установке и настройке необходимого ПО

### Установка Docker:

Для Windows и MacOS скачайте и установите Docker Desktop с официального сайта Docker.

Для Linux выполните следующие команды:

```bash
sudo apt-get update
sudo apt-get install docker
```

### Установка Docker Compose:

Выполните следующую команду для установки Docker Compose:

```bash
sudo apt-get install docker-compose
```

# Архитектура

## Обзор архитектуры веб-сервиса, включая используемые технологии,
компоненты и их взаимодействие

### Backend (Kotlin с использованием Spring Boot)

Веб-сервис построен на основе Kotlin с использованием Spring Boot, что обеспечивает быструю разработку и управление приложениями. Основные используемые технологии включают:

- **Spring Boot**: Фреймворк для создания автономных, готовых к продакшену приложений на основе Spring.
- **Spring Security**: Инфраструктура для обеспечения аутентификации и авторизации в приложениях.
- **Spring Data JPA**: Упрощает взаимодействие с базами данных через JPA (Java Persistence API) и Hibernate.
- **Spring Actuator**: Предоставляет возможности мониторинга и управления приложением в реальном времени.
- **Liquibase:** Читает .XML файлы с оописанием миграции баз данных.

### Frontend (Svelte с использованием Vite)

Фронтенд приложения разработан на базе Svelte с использованием Vite для быстрой сборки и разработки. Важные компоненты включают:

- **Svelte**: Прогрессивный фреймворк JavaScript для построения пользовательских интерфейсов.
- **Vite**: Быстрый инструмент сборки для современных веб-приложений с поддержкой быстрого развертывания и горячей перезагрузки.
- **Tailwind CSS**: Библиотека CSS, которая упрощает стилизацию компонентов и создание адаптивного дизайна.

### Взаимодействие компонентов

- **Фронтенд и бекенд**: Фронтенд обращается к бекенду через API, предоставляемые Spring Boot. Это включает запросы на получение данных, отправку данных и аутентификацию пользователя (JWT).
- **База данных**: Бекенд взаимодействует с PostgreSQL для хранения и извлечения данных. Используется Spring Data JPA для выполнения операций CRUD (Create, Read, Update, Delete).
- **Безопасность и аутентификация**: Spring Security обеспечивает защиту API и управление доступом к различным ресурсам в зависимости от роли пользователя.

### Развёртывание и сборка

- Проект поддерживается и собирается при помощи инструментов сборки Gradle и npm (Node Package Manager).

## Диаграммы, поясняющая структуру и поток данных

Пользователь получает SSR страницу с сервиса Vercel, затем браузер пользователя с загруженной страницей обращается к API хоста бэкенда, в запросах с данными идет вызов запросов к базе данных.

![Архитектура](/misc/images/architecture.png)

# Инструкция по развертыванию

### Клонирование репозитория:

Перейдите в директорию, где вы хотите разместить проект, и выполните команду:

```bash
git clone https://github.com/funcid/metro-in-tandem.git
cd metro-in-tandem
```

### Запуск проекта:

```bash
docker-compose up --build
```

**База данных (PostgreSQL)**: будет доступна на порту, указанном в переменной `POSTGRES_PORT` в файле `.env`. По умолчанию это порт 5432

**Бэкенд**: будет доступен на порту 8080

**Фронтенд**: будет доступен на порту 3000

**ETL:** перенесет данные из JSON файлов и загрузит их в базу

# Инструкция по эксплуатации

## Описание доступных API методов и их параметров и ожидаемых ответов

Динамическое описание API методов доступно в Swagger по ссылке:

[https://api.метровтандеме.рф/swagger-ui/index.html](https://api.xn--80adhbda7bfghvxd.xn--p1ai/swagger-ui/index.html)

## Инструкции по аутентификации и авторизации

1. Посетите сайт [https://метровтандеме.рф](https://метровтандеме.рф) 

    ![Главная страница](/misc/images/main.png)
    
2. Нажмите “Войти” или любую кнопку из меню навигации
    
    ![Страница входа](/misc/images/login.png)
    
3. Введите логин и пароль, по умолчанию, доступны следующие учетные записи с ролями:
    
    ![Заполненная анкета](/misc/images/data.png)
    
    1. Администратор
        
        ```bash
        admin_user
        admin_pass
        ```
        
    2. Специалист
        
        ```bash
        specialist_user
        specialist_pass
        ```
        
    3. Оператор
        
        ```bash
        operator_user
        operator_pass
        ```
        
    4. Работник
        
        ```bash
        admin_user
        admin_pass
        ```
        
4. Справа сверху исчезнет кнопка “Войти” и появится активная учетная запись
    
    ![Успешный вход](/misc/images/authorized.png)
    
5. Для выхода из учетной записи нажмите на кнопку справа сверху, далее: Выйти
    
    ![Выход](/misc/images/logout.png)

# Описание алгоритма распределения заявок

## Описание работы алгоритма

Алгоритм в классе `AllocationService` выполняет распределение заявок (`Application`) между сотрудниками (`Employee`). Основные шаги алгоритма следующие:

1. **Инициализация и подготовка**:
   - Очистка текущих распределений (`allocation.clear()`).
   - Извлечение списка сотрудников и заявок в заданном диапазоне времени (`from` и `to`).
   - Если требуется перераспределение (`reallocate == true`), то:
     - Удаление всех существующих распределений из базы данных.
     - Распределение заявок среди подходящих сотрудников.
     - Обеспечение обеденного перерыва для всех сотрудников.
     - Логирование неудачных распределений.
     - Сохранение новых распределений в базе данных.
   - В противном случае загрузка текущих распределений из базы данных и группировка их по сотрудникам.

2. **Поиск валидных заявок**:
   - Метод `findValidApplications` извлекает заявки из базы данных, которые попадают в заданный временной интервал и не отменены.

3. **Распределение заявок**:
   - Метод `allocateToSuitableEmployees` распределяет заявки среди сотрудников, разделяя их на группы по рангу ("ЦИ" и "ЦСИ").
   - Для каждой заявки находит подходящих сотрудников и определяет лучшего сотрудника для выполнения заявки на основе времени путешествия.

4. **Проверка доступности сотрудников**:
   - Метод `isEmployeeAvailable` проверяет, доступен ли сотрудник для выполнения новой заявки, основываясь на текущих распределениях и рабочем времени.

5. **Обеспечение обеденного перерыва**:
   - Метод `ensureLunchBreakForAllEmployees` добавляет обеденный перерыв для каждого сотрудника, если это необходимо.

6. **Оценка времени путешествия**:
   - Метод `estimateTravelTime` оценивает время, необходимое для перемещения сотрудника от последней заявки к новой.

## Сложность алгоритма

Теперь рассмотрим сложность различных частей алгоритма.

1. **Метод `allocateApplications`**:
   - Очистка текущих распределений: `O(1)`.
   - Извлечение списка сотрудников: `O(E)`, где `E` - количество сотрудников.
   - Извлечение списка заявок: `O(A)`, где `A` - количество заявок.
   - Удаление всех распределений из базы данных: `O(N)`, где `N` - количество текущих распределений.
   - Основной цикл распределения заявок:
     - Поиск подходящих сотрудников для каждой заявки: `O(A * E)`.
     - Обеспечение обеденного перерыва для всех сотрудников: `O(E * A)`.
     - Логирование неудачных распределений: `O(E)`.

2. **Метод `findValidApplications`**:
   - Извлечение заявок из базы данных: `O(A)`.
   - Фильтрация заявок: `O(A)`.

3. **Метод `allocateToSuitableEmployees`**:
   - Фильтрация сотрудников по рангу: `O(E)`.
   - Основной цикл распределения заявок:
     - Поиск подходящих сотрудников для каждой заявки: `O(A * E)`.
     - Поиск лучшего сотрудника для каждой заявки: `O(A * E)`.

4. **Метод `isEmployeeAvailable`**:
   - Проверка наличия пересечений в распределениях сотрудника: `O(A)` (в худшем случае).
   - Проверка соответствия рабочему времени: `O(1)`.

## Итоговая сложность

- В худшем случае основная сложность алгоритма определяется этапом распределения заявок среди сотрудников: `O(A * E)`, где `A` - количество заявок, `E` - количество сотрудников. 

Таким образом, общая сложность алгоритма `allocateApplications` равна `O(A * E)`.